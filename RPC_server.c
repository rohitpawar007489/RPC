/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
 
 
 /*
  * Author : Rohit Pawar
  * Assignment 2 : Implementation of RPC Principle
  * Server program is responsible to carry out requested task and return result back to client
 */


#include "RPC.h"
#include <unistd.h>

//Return current working directory 
my_string *
pwd_command_to_retrieve_path_1_svc(void *argp, struct svc_req *rqstp)
{
	static my_string  result;
	char cwd[10240];
	//function to retrieve current working directory 
	if(getcwd(cwd,sizeof(cwd))!=NULL)
	{
		result.data = cwd;
	}
	return &result;
}

//Sort given input array
my_integer_one_dimensional_array *
sort_1_svc(my_integer_one_dimensional_array *argp, struct svc_req *rqstp)
{
	static my_integer_one_dimensional_array  result;
	result.size= argp->size;
	int i,j,swap;
	
	//Sort given array using selection sort
	for(i=0;i<result.size;i++)
	{
		for(j=i+1;j<result.size;j++)
		{
			if(argp->data[i] > argp->data[j])
			{
				swap = argp->data[i];
				argp->data[i]=argp->data[j];
				argp->data[j]=swap;
			}
		}
	}
	//copy sorted array to result array
	for(i=0;i<result.size;i++)
	{
		result.data[i]=argp->data[i];
	}
	return &result;
}

//Echo clients message
my_string *
echo_client_1_svc(my_string *argp, struct svc_req *rqstp)
{
	static my_string  result;
	result.data=argp->data; //copy clients message to result
	return &result;
}

//Check if file exist
my_string *
check_file_exist_1_svc(my_string *argp, struct svc_req *rqstp)
{
	static my_string  result;
	//Function to check file exist or not
	if(access(argp->data,F_OK)==0) // F_OK flag is used to check file existance
	{
		result.data = "File Exist";
	}
	else
	{
		result.data = "File does not Exist";
	}
	return &result;
}

//Matrix Multiplication
my_integer_two_dimensional_array *
matrixmultiplication_1_svc(matrix_multiplication_input *argp, struct svc_req *rqstp)
{
	static my_integer_two_dimensional_array  result;
	int i,j,k;
	
	int matrix1[argp->matrix1.row][argp->matrix1.column];
	int matrix2[argp->matrix2.row][argp->matrix2.column];

	//Copying received matrix 1 into local matrix1
	for(i=0;i<argp->matrix1.row;i++)
	{
		for(j=0;j<argp->matrix1.column;j++)
		{
			matrix1[i][j] = argp->matrix1.data[i*argp->matrix1.column+j];
		}
	}
	
	//Copying received matrix 2 into local matrix2
	for(i=0;i<argp->matrix2.row;i++)
	{
		for(j=0;j<argp->matrix2.column;j++)
		{
			matrix2[i][j] = argp->matrix2.data[i*argp->matrix2.column+j];
		}
	}
	
	//Matrix Multiplication
	result.row = argp->matrix1.row;
	result.column = argp->matrix2.column;
	int result_matrix[result.row][result.column];
	
	//intializing result to 0
	for ( i = 0; i < result.row; i++) 
	{
        for ( j = 0; j < result.column; j++) 
		{
                result_matrix[i][j] = 0;
        }
    }
	//carry out multiplication
    for ( i = 0; i < result.row; i++) 
	{ 
        for ( j = 0; j < result.column; j++) 
		{ 
            for ( k = 0; k < argp->matrix1.column ; k++) 
			{ 
                    result_matrix[i][j] += matrix1[i][k] * matrix2[k][j];
            }
        }
    }
	//Copying resultant matrix into result,which can then be used to send it to client
	int result_matrix_size = result.row *result.column;
	for(i = 0; i<result_matrix_size; ++i) 
	{
		result.data[i] = result_matrix[i/result.column][i%result.column];
	}
	
	return &result;
}
